#!/opt/perl/bin/perl
use strict;
use warnings;
use 5.010_000;
use feature ':5.10';
use Getopt::Long qw( GetOptions );
use Runops::Movie::Util qw( pretty_size );
use File::Spec::Functions qw( catfile );
use Carp ();
use Treemap::Output::Imager;
use Treemap::Squarified;

$SIG{__DIE__} = \&Carp::confess;

GetOptions(
    help         => sub { die 'pod2usage( -verbose => 2 )' },
    'less-mem'   => \my($less_memory),
    'dir=s'      => \my($dir),
    'width=i'    => \my($width),
    'height=i'   => \my($height),
    'size=s'     => \my($in_size),
    'edge=s'     => \my($in_edge),
    'type=s'     => \my($in_type),
    'name=s'     => \my($in_name),
    'font=s'     => \my($in_font),
    'png=s'      => \my($out_png),
)
  or die 'pod2usage( -verbose => 2 )';

$width //= 1024;
$height //= 768;

if ( $less_memory ) {
    require Judy;
}

# --dir automagic
#
if ( $dir ) {
    $in_size //= catfile( $dir, 'frame.size' );
    $in_edge //= catfile( $dir, 'frame.edge' );
    $in_type //= catfile( $dir, 'frame.type' );
    $in_name //= catfile( $dir, 'frame.name' );

    $in_font //= 'ImUgly.ttf';

    $out_png //= catfile( $dir, 'frame.png' );
}

if ( ! -e $in_font ) {
    die "Missing $in_font";
}

say "Read $_ (@{[ pretty_size( -s $_ ) ]})" for $in_size, $in_edge, $in_type, $in_name;
my $input = Treemap::Input::Edge->new;
$input->load(
    size => $in_size,
    edge => $in_edge,
	type => $in_type,
    names => $in_name,
);

my $output = Treemap::Output::Imager->new(
    WIDTH => $width,
    HEIGHT => $height,
    FONT_FILE => $in_font,
);

my $treemap = Treemap::Squarified->new(
    INPUT  => $input,
    OUTPUT => $output,
);

$treemap->map;

$output->save( $out_png );
say "Wrote $out_png (@{[ pretty_size( -s $out_png ) ]})";
exit;

package Treemap::Input::Edge;
use strict;
use warnings;
use constant Tie => 'Treemap::Input::Edge::Tie';

package Treemap::Input::Edge::Tie;
use strict;
use warnings;
use feature ':5.10';
use constant SIZE   => 0;
use constant EDGE   => 1;
use constant TYPE   => 2;
use constant NAMES  => 3;
use constant NAME   => 4;
use constant COLORS => {
    null => 'grey',
    pvgv => 'red',
    pvav => 'green',
    pvcv => 'cyan',
    pvmg => 'golden',
    pvio => 'golden',
    ''   => 'black',
    pvbm => 'yellow',
    nv   => 'yellow',
    pvlv => 'yellow',
    pv   => 'blue',
    iv   => 'yellow',
    rv   => 'orange',
    pviv => 'yellow',
    pvnv => 'yellow',
    pvhv => 'brown',
};

my %seen;
sub TIEHASH {
    my ( undef, @s ) = @_;
    bless \ @s, $_[0];
}
sub FETCH {
    my ( $self, $key ) = @_;

    given ( $key ) {
        when('colour') {
            my $name = $self->[NAME];
            my $type = $self->[TYPE]{ $name };
            if ( ! defined $type ) {
                say "Missing type $name";
                $type = '';
            }
            my $color;
            if ( ! exists COLORS->{$type} ) {
                say "Missing color [$type]";
                $color = COLORS->{''};
            }
            else {
                $color = COLORS->{$type};
            }
            return $color;
        }
        when ('children') {
            my $class    = ref $self;
            my $outbound = $self->[EDGE]{$self->[NAME]};
            return if ! $outbound;

            my @children =
                map {
                    my $name = $_;
                    my %child;
                    tie %child, $class,
                        $self->[SIZE],
                        $self->[EDGE],
                        $self->[TYPE],
                        $self->[NAMES],
                        $name;

                    \ %child;
                }
                grep { exists $self->[TYPE]{$_} }
                    # grep { 0.000001 <= $self->[SIZE]{$_} / $self->[SIZE]{root} }
                keys %$outbound;

            return \ @children;
        }
        when ('name') {
            return $self->[NAMES]{ $self->[NAME] } // '';
            #return $self->[NAME];
        }
        when ('size') {
            return $self->[SIZE]{$self->[NAME]};
        }
        default {
            die "@_";
        }
    }
}

package Treemap::Input::Edge;
use Treemap::Input;
BEGIN { @Treemap::Input::Edge::ISA = 'Treemap::Input' }

BEGIN { our $VERSION = '0.01' }

sub load {
    my ( $self, %path ) = @_;

    my %size;
    {
        tie %size, 'Judy::L';
        open my($fh), $path{size}
            or die "Can't open $path{size}: $!";
        while (my $line = <$fh>) {
            my ($x,$s) = $line =~ /^\w+\(([[:xdigit:]]+),(\d+)\)\.$/;
            $size{hex "0x$x"} = $s;
        }
    }

    my %edge;
    {
        tie %edge, Judy => 'L -> 1';
        open my($fh), $path{edge}
            or die "Can't open $path{edge}: $!";
        while ( my $line = <$fh> ) {
            my ($x,$y) = $line =~ /^\w+\(([[:xdigit:]]+),([[:xdigit:]]+)\)\.$/;
            $edge{hex "0x$x"}{hex "0x$y"} = 1;
        }
    }

    my %type;
    {
        open my($fh), $path{type}
            or die "Can't open $path{type}: $!";
        while (my $line = <$fh>) {
            my ($x,$t) = $line =~ /^\w+\(([[:xdigit:]]+),'?(.+)'?\)\.$/;
            $type{hex "0x$x"} = $t;
        }
    }

    my %names;
    {
        open my($fh), $path{names}
            or die "Can't open $path{names}: $!";
        while (my $line = <$fh>) {
            my ($x,$n) = $line =~ /^\w+\(([[:xdigit:]]+),'?(.+)\)\.$/;
            $names{hex "0x$x"} = $n;
        }
    }

    my %hash;
    tie %hash, Treemap::Input::Edge::Tie,
        \ %size, \%edge, \%type, \%names,
        '0';
    $self->{DATA} = \ %hash;

    return 1;
}

1;
