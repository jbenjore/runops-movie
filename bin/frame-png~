#!/opt/perl/bin/perl
use strict;
use warnings;
use 5.010_000;
use feature ':5.10';
use Getopt::Long qw( GetOptions );
use Runops::Movie::Util qw( pretty_size );
use File::Spec::Functions qw( catfile );
use Carp ();
use Treemap::Output::Imager;
use Judy;

$SIG{__WARN__} = sub { no warnings; Carp::cluck( @_ );  $DB::signal = 1; };
$SIG{__DIE__} = \&Carp::confess;

GetOptions(
    help         => sub { die 'pod2usage( -verbose => 2 )' },
    'less-mem'   => \my($less_memory),
    'dir=s'      => \my($dir),
    'width=i'    => \my($width),
    'height=i'   => \my($height),
    'sum-size=s' => \my($in_sum_size),
    'edge=s'     => \my($in_edge),
    'type=s'     => \my($in_type),
    'name=s'     => \my($in_name),
    'font=s'     => \my($in_font),
    'png=s'      => \my($out_png),
)
  or die 'pod2usage( -verbose => 2 )';

$width //= 1024;
$height //= 768;

# --dir automagic
#
if ( $dir ) {
    $in_sum_size //= catfile( $dir, 'frame.sum-size' );
    $in_edge //= catfile( $dir, 'frame.edge' );
    $in_type //= catfile( $dir, 'frame.type' );
    $in_name //= catfile( $dir, 'frame.name' );

    $in_font //= 'ImUgly.ttf';

    $out_png //= catfile( $dir, 'frame.png' );
}

if ( ! -e $in_font ) {
    die "Missing $in_font";
}

say "Read $_ (@{[ pretty_size( -s $_ ) ]})" for $in_sum_size, $in_edge, $in_type, $in_name;
my $input = Treemap::Input::Edge->new;
$input->load(
    size => $in_sum_size,
    edge => $in_edge,
	type => $in_type,
    names => $in_name,
);

my $output = Treemap::Output::Imager->new(
    WIDTH => $width,
    HEIGHT => $height,
    FONT_FILE => $in_font,
);

my $treemap = Treemap::Squarified->new(
    INPUT  => $input,
    OUTPUT => $output,
);

say 'Mapping';
$treemap->map;

$output->save( $out_png );
say "Wrote $out_png (@{[ pretty_size( -s $out_png ) ]})";
exit;

package Treemap::Input::Edge;
use strict;
use warnings;
use constant Tie => 'Treemap::Input::Edge::Tie';

package Treemap::Input::Edge::Tie;
use strict;
use warnings;
use feature ':5.10';
use constant SIZE   => 0;
use constant EDGE   => 1;
use constant TYPE   => 2;
use constant NAMES  => 3;
use constant NAME   => 4;
use constant COLORS => {
    NULL => 'grey',
    PVGV => 'red',
    PVAV => 'green',
    PVCV => 'cyan',
    PVMG => 'golden',
    PVIO => 'golden',
    ''   => 'black',
    PVBM => 'yellow',
    NV   => 'yellow',
    PVLV => 'yellow',
    PV   => 'blue',
    IV   => 'yellow',
    RV   => 'orange',
    PVIV => 'yellow',
    PVNV => 'yellow',
    PVHV => 'brown',
};

my %seen;
sub TIEHASH {
    my ( undef, @s ) = @_;
    bless \ @s, $_[0];
}
sub FETCH {
    my ( $self, $key ) = @_;

    given ( $key ) {
        when('colour') {
            my $name = $self->[NAME];
            my $type = $self->[TYPE]{ pack 'i', $name };
            if ( ! defined $type ) {
                say "Missing type $name";
                $type = '';
            }
            my $color;
            if ( ! exists COLORS->{$type} ) {
                say "Missing color [$type]";
                $color = COLORS->{''};
            }
            else {
                $color = COLORS->{$type};
            }
            return $color;
        }
        when ('children') {
            my $class    = ref $self;
            my ( $pyedge, $yedge ) = Judy::L::Get($self->[EDGE],$self->[NAME]);
            return if ! $pyedge;

            my @children;

            my $y = Judy::1::First($yedge,0);
            while ( defined $y ) {
                my %child;
                tie %child, $class,
                    $self->[SIZE],
                    $self->[EDGE],
                    $self->[TYPE],
                    $self->[NAMES],
                    $y;

                push @children, \ %child;

                $y = Judy::1::Next($yedge,$y);
            }

            return \ @children;
        }
        when ('name') {
            return $self->[NAMES]{ pack 'i', $self->[NAME] } // '';
            #return $self->[NAME];
        }
        when ('size') {
            if ( exists $self->[SIZE] ) {
                my ( undef, $size ) = Judy::L::Get($self->[SIZE],$self->[NAME]);
                return $size;
            }
            else {
                warn "Missing size $self->[NAME]";
                return 0;
            }
        }
        default {
            die "@_";
        }
    }
}

package Treemap::Input::Edge;
use Treemap::Input;
BEGIN { @Treemap::Input::Edge::ISA = 'Treemap::Input' }

BEGIN { our $VERSION = '0.01' }

sub load {
    my ( $self, %path ) = @_;

    my $edge = 0;
    {
        open my($fh), $path{edge}
            or die "Can't open $path{edge}: $!";
        while ( my $line = <$fh> ) {
            my ($x,$y) = $line =~ /^edge\(([[:xdigit:]]+),([[:xdigit:]]+)\)\.$/;
            $x = hex "0x$x";
            $y = hex "0x$y";
            my ( $pyedge, $yedge ) = Judy::L::Get($edge,$x);
            if ( $pyedge ) {
                my $oyedge = $yedge;
                Judy::1::Set($yedge,$y);
                if ( $oyedge != $yedge ) {
                    Judy::Mem::Poke($pyedge,$yedge);
                }
            }
            else {
                my $yedge = 0;
                Judy::1::Set($yedge,$y);
                Judy::L::Set($edge,$x,$yedge);
            }
        }
    }

    my $size = 0;
    {
        open my($fh), $path{size}
            or die "Can't open $path{size}: $!";
        while (my $line = <$fh>) {
            my ($x,$s) = $line =~ /^size\(([[:xdigit:]]+),(\d+)\)\.$/;
            Judy::L::Set($size, hex "0x$x", $s);
        }
    }

    my %type;
    {
        open my($fh), $path{type}
            or die "Can't open $path{type}: $!";
        while (my $line = <$fh>) {
            my ($x,$t) = $line =~ /^type\(([[:xdigit:]]+),'?(.*?)'?\)\.$/;
            $type{pack 'i', hex "0x$x"} = $t;
        }
    }

    my %names;
    {
        open my($fh), $path{names}
            or die "Can't open $path{names}: $!";
        while (my $line = <$fh>) {
            my ($x,$n) = $line =~ /^name\(([[:xdigit:]]+),'(.*)'\)\.$/;
            $names{pack 'i', hex "0x$x"} = $n;
        }
    }

    my %hash;
    tie %hash, Treemap::Input::Edge::Tie,
        $size, $edge, \%type, \%names,
        0;
    $self->{DATA} = \ %hash;

    return 1;
}
use Treemap::Squarified;

1;
