#!/opt/perl/bin/perl
use strict;
use warnings;
use 5.010_000;
use feature ':5.10';
use Getopt::Long qw( GetOptions );
use Runops::Movie::Util qw( pretty_size );
use File::Spec::Functions qw( catfile );
use Carp ();
use Judy ();

$Devel::Trace::TRACE = 0;
Judy::trace( 0 );

$SIG{__WARN__} = \&Carp::cluck;


sub trace {
    if ( $Devel::Trace::TRACE ) {
        goto &Carp::cluck;
    }
}

# Read options
#
my ( %in, %out );
GetOptions(
    help         => sub { die 'pod2usage( -verbose => 2 )' },
    'less-mem'   => \my($less_memory),
    'dir=s'      => \my($dir),
    (
        map {; "$_=s" => \$in{$_}{name} }
        qw( contains size shares function vertex )
    ),
    (
        map {; "$_=s" => \$out{$_}{name} }
        qw( fulledge )
    )
)
  or die 'pod2usage( -verbose => 2 )';

if ( $less_memory ) {
    require Judy;
}

# --dir automagic
#
if ( $dir ) {
    $in{$_}{name} //= catfile( $dir, "frame.$_" ) for keys %in;
    $out{$_}{name} //= catfile( $dir, "frame.$_" ) for keys %out;
}

# Option validation
#
trace( 'No option validation' );

require Inline;

# Add verticies
#
my $vertices;
{
    say 'vertex(Id).';

    say "Read $in{contains}{name} (@{[ pretty_size( -s $in{contains}{name} ) ]})";
    open my($fh), '<', $in{contains}{name}
        or die "Can't read $in{contains}{name}: $!";

Inline->bind( C => <<"..." );
#line @{[ __LINE__ ]}
#include <Judy.h>

void
read_contains( PerlIO* fh, SV *vertices_sv ) {
    SV line_sv;
    char *line;
    STRLEN line_len;
    int x, y;
    int Rc_int;

    Pvoid_t vertices = SvIV( vertices_sv );
    while (sv_gets( &line_sv, fh, 0 )) {
        line = SvPV( &line_sv, line_len );
        sscanf( line, "contains(%x,%x).", x, y );

        PerlIO_printf(PerlIO_stdout(), "x=%x y=%x\\n", x, y );
        J1S(Rc_int,vertices,x);
        J1S(Rc_int,vertices,y);
    }
    sv_setiv( vertices_sv, vertices );
}
...
    $vertices += 0;
    read_contains( $fh, $vertices );
}



{
    say "Read $in{shares}{name} (@{[ pretty_size( -s $in{shares}{name} ) ]})";
    open my($fh), '<', $in{shares}{name}
        or die "Can't read $in{shares}{name}: $!";
#    eval_c(<<"...");
#        #include <stdio.h>
#
#        Pvoid_t vertices = SvIV( (SV*)@{[ 0 + \$vertices ]} );
#        IO *fh = sv_2io( (SV*)@{[ ]} );
#        SV line_sv;
#        char *line;
#        int x, y;
#        while (sv_gets( &line_sv, fh, 0 )) {
#          line = SvPV( &line_sv );
#          sscanf( SvPV( &line ), "shares(%x,%x).", x, y );
#
#          PerlIO_printf(PerlIO_stdout(), "x=%x y=%x\n", x, y );
#          Judy::1::Set(vertices,x);
#          Judy::1::Set(vertices,y);
#        }
#        sv_setiv( (SV*)@{[ 0+\$vertices ]}, vertices );
#...
}




# Add missing vertices
#
{
    say 'missing(vertex(Id)).';
    say "Read $in{size}{name} (@{[ pretty_size( -s $in{size}{name} ) ]})";
    open my($fh), '<', $in{size}{name}
        or die "Can't read $in{size}{name}: $!";
    while (defined(my $_ = <$fh>)) {
        next if !( my ( $x ) = /^size\(([[:xdigit:]]+)/ );
        
        Judy::1::Set($vertices, hex "0x$x");
    }
}



# Add edges, but only if they don't produce cycles
#
my( %fulledge, $contained );
if ( $less_memory ) {
    tie %fulledge, Judy => 'L -> 1';
}
{
    say 'edge(ParentId,ChildId).';
    
    for my $file ( $in{contains}{name}, $in{shares}{name} ) {
        say "Read $file (@{[ pretty_size( -s $file ) ]})";
        open my($fh), '<', $file
            or die "Can't open $file: $!";
        
        while (defined(my $_ = <$fh>)) {
            next if !( my ( $x, $y ) = /^[^(]+\(([[:xdigit:]]+),([[:xdigit:]]+)/ );
            $x = hex "0x$x";
            $y = hex "0x$y";
            
            $fulledge{$x}{$y} = $less_memory ? 1 : undef;
            if ( is_self_loop_vertex( $y ) ) {
                delete $fulledge{$x}{$y};

                if ( ! keys %{$fulledge{$x}} ) {
                    delete $fulledge{$x};
                }
            }
            else {
                Judy::1::Set($contained,$y);
            }
        }
    }
}

# Exterior nodes become property of 'root'
#
{
    say q{edge(0,Id).};
    
    my %root;
    if ( $less_memory ) {
        tie %root, 'Judy::1';
    }
    my $x = Judy::1::First( $vertices, 0 );
    while ( defined $x ) {
        if ( Judy::1::Test( $contained, $x ) ) {
        }
        else {
            $root{$x} = $less_memory ? 1 : undef;
        }

        $x = Judy::1::Next( $vertices, $x );
    }

    $fulledge{0} = \ %root;
}

Judy::1::Free( $contained );
Judy::1::Free( $vertices );

# $DB::signal = 1;
# Judy::trace( 1 );
# $Devel::Trace::TRACE = 1;

{
    open my($fh), '>', $out{fulledge}{name}
        or die "Can't open $out{fulledge}{name} for writing: $!";
    keys %fulledge;
    while ( defined ( my $x = each %fulledge ) ) {
        my $yedge = $fulledge{$x};
        my $xx = sprintf '%x', $x;
        
        keys %$yedge;
        while ( defined( my $y = each %$yedge ) ) {
            my $yx = sprintf '%x', $y;
            say { $fh } "edge($xx,$yx).";
        }
        %$yedge = ();
    }
    %fulledge = ();
    untie %fulledge if tied %fulledge;
    say "Wrote $out{fulledge}{name} e(@{[ pretty_size( -s $out{fulledge}{name} ) ]})";
}

sub is_self_loop_vertex {
    my ( $v ) = @_;

    my @todo = $v;
    while ( @todo ) {
        my $x = shift @todo;
        my $yedge = $fulledge{$x};

        keys %$yedge;
        while ( defined( my $y = each %$yedge ) ) {
            return 1 if $y eq $v;
            push @todo, $y;
        }
    }

    return 0;
}
